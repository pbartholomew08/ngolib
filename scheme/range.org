#+TITLE: Range

Implements the ~range~ function returning the list of numbers from ~start~ until, but excluding, ~stop~
in increments of ~step~.

The ~(iota count start step)~ function of ~srfi-1~ returns a list of ~count~ elements, starting from ~start~
and incrementing by ~step~.
This is essentially the functionality of the ~range~ function, however rather than a ~count~ we are
given the value we must ~stop~ before.
The implementation of ~range~ in listing\nbsp[[range.scm]] uses ~iota~ to compute this list, with a ~count~
determined by the supplied ~start~, ~stop~ and ~step~ arguments.

#+CAPTION: The ~range~ function.
#+NAME: range.scm
#+begin_src scheme
  (use-modules (srfi srfi-1))

  (define (range start stop step)
    "Function that returns the list of numbers between start and stop when incremented by step."
    (iota (count start stop step)
          start
          step))
#+end_src

Listing\nbsp[[count.scm]] implements a ~count~ function which will return the number of steps /if/ it is
possible to get to ~stop~ from ~start~ with an increment of ~step~.

#+CAPTION: The ~count~ function.
#+NAME: count.scm
#+begin_src scheme
  (define (count start stop step)
    "Get the count of steps from start to stop."
    (if (and (reachable? start stop step)
             (> step 0))
        (floor (/ (- stop start)
                  step))
        0))
#+end_src

The ~reachable?~ predicate implemented in listing\nbsp[[reachable.scm]] determines whether the combination of
~start~, ~stop~ and ~step~ is valid: a positive, finite number of ~step~'s will eventually reach ~stop~ from
~start~.

#+CAPTION: The ~reachable?~ predicate.
#+NAME: reachable.scm
#+begin_src scheme
  (define (reachable? start stop step)
    "Is stop reachable from start using step?"
    (>= (* (- stop start)
           step)
        0))
#+end_src

#+CAPTION: The ~ngo range~ module.
#+begin_src scheme :noweb no-export :tangle range.scm
  (define-module (ngo range)
    #:export (range))

  <<reachable.scm>>
  <<count.scm>>
  <<range.scm>>
#+end_src

* Tests

The test program in listing\nbsp[[test:range.scm]] consists of several test suites to check properties of
the ~range~ function, detailed below.

#+CAPTION: The ~range~ test program.
#+NAME: test:range.scm
#+begin_src scheme :noweb no-export :tangle test-range.scm
  (use-modules (srfi srfi-64)) ; Load unit-testing SRFI
  (use-modules (ngo range))    ; Load the range module

  <<valid-input.scm>>

  <<test:start-eq-stop.scm>>
  <<test:start-ne-stop.scm>>
  <<test:invalid.scm>>
#+end_src

** ~start == stop~

This test suite considers the case when calling ~range~ with equal ~start~ and ~stop~ values.

#+CAPTION: Test suite for calling ~range~ with equal ~start~ and ~stop~ arguments returns the empty list.
#+NAME: test:start-eq-stop.scm
#+begin_src scheme :noweb no-export
  (test-begin "start-eq-stop")

  <<test:start-eq-stop:reachable?.scm>>
  <<test:start-eq-stop:count.scm>>
  <<test:start-eq-stop:range.scm>>

  (test-end "start-eq-stop")
#+end_src

*** reachable?

When the ~start~ and ~stop~ are equal ~reachable?~ should return ~#t~ as we have reached the ~stop~ already!

#+CAPTION: Test cases for calling ~reachable?~ with equal ~start~ and ~stop~ values.
#+NAME: test:start-eq-stop:reachable?.scm
#+begin_src scheme
  (define ngo-range:reachable? (@@ (ngo range) reachable?)) ; Get the unexported reachable? predicate

  (test-assert "reachable? 0 0 0" (ngo-range:reachable? 0 0 0))
  (test-assert "reachable? 0 0 1" (ngo-range:reachable? 0 0 1))
  (test-assert "reachable? 0 0 -1" (ngo-range:reachable? 0 0 -1))

  (test-assert "reachable? 1 1 0" (ngo-range:reachable? 1 1 0))
  (test-assert "reachable? 1 1 1" (ngo-range:reachable? 1 1 1))
  (test-assert "reachable? 1 1 -1" (ngo-range:reachable? 1 1 -1))

  (test-assert "reachable? -1 -1 0" (ngo-range:reachable? -1 -1 0))
  (test-assert "reachable? -1 -1 1" (ngo-range:reachable? -1 -1 1))
  (test-assert "reachable? -1 -1 -1" (ngo-range:reachable? -1 -1 -1))
#+end_src

*** count

When the ~start~ and ~stop~ are equal the ~count~ function should return ~0~.

#+CAPTION: Test cases for calling ~count~ with equal ~start~ and ~stop~ values.
#+NAME: test:start-eq-stop:count.scm
#+begin_src scheme
  (define ngo-range:count (@@ (ngo range) count)) ; Get the unexported count function

  (define expected-val 0)

  (test-equal "count 0 0 0" expected-val (ngo-range:count 0 0 0))
  (test-equal "count 0 0 1" expected-val (ngo-range:count 0 0 1))
  (test-equal "count 0 0 -1" expected-val (ngo-range:count 0 0 -1))

  (test-equal "count 1 1 0" expected-val (ngo-range:count 1 1 0))
  (test-equal "count 1 1 1" expected-val (ngo-range:count 1 1 1))
  (test-equal "count 1 1 -1" expected-val (ngo-range:count 1 1 -1))

  (test-equal "count -1 -1 0" expected-val (ngo-range:count -1 -1 0))
  (test-equal "count -1 -1 1" expected-val (ngo-range:count -1 -1 1))
  (test-equal "count -1 -1 -1" expected-val (ngo-range:count -1 -1 -1))
#+end_src

*** range

When the ~start~ and ~stop~ are equal ~range~ should return an empty list.

#+CAPTION: Test cases for calling ~range~ with equal ~start~ and ~stop~ values.
#+NAME: test:start-eq-stop:range.scm
#+begin_src scheme
  (define (test-util:start==stop start step)
    "Utility function to check range returns empty list when start=stop."
    (null? (range start start step)))

  (test-assert "0 0" (test-util:start==stop 0 0))
  (test-assert "0 1" (test-util:start==stop 0 1))
  (test-assert "0 -1" (test-util:start==stop 0 -1))

  (test-assert "1 0" (test-util:start==stop 1 0))
  (test-assert "1 1" (test-util:start==stop 1 1))
  (test-assert "1 -1" (test-util:start==stop 1 -1))

  (test-assert "-1 0" (test-util:start==stop -1 0))
  (test-assert "-1 1" (test-util:start==stop -1 1))
  (test-assert "-1 -1" (test-util:start==stop -1 -1))
#+end_src

** ~start /= stop~

When the ~start~ and ~stop~ are not equal ~range~ should return a non-empty list.
This test suite doesn't check the validity of the list, only that it is non-empty.

#+CAPTION: Test suite calling ~range~ with unequal ~start~ and ~stop~ arguments should return a non-empty list.
#+NAME: test:start-ne-stop.scm
#+begin_src scheme
  (test-begin "start-ne-stop")

  (define (test-util:start/=stop start stop step)
    "Utility function to check range returns non-empty list when start/=stop, i.e. for a valid input."
    (and (valid-input? start stop step) ; Ensure test condition is met.
         (not (null? (range start stop step)))))

  (test-assert "0 1 +" (test-util:start/=stop 0 1 1))
  (test-assert "0 -1 -" (test-util:start/=stop 0 -1 -1))

  (test-assert "1 0 -" (test-util:start/=stop 1 0 -1))
  (test-assert "1 -1 -" (test-util:start/=stop 1 -1 -1))
  (test-assert "1 2 -" (test-util:start/=stop 1 2 1))

  (test-assert "-1 0 +" (test-util:start/=stop -1 0 1))
  (test-assert "-1 1 +" (test-util:start/=stop -1 1 1))
  (test-assert "-1 -2 -" (test-util:start/=stop -1 -2 -1))

  (test-end "start-ne-stop")
#+end_src

** Invalid ~step~ / ~start-stop~ combination

When the ~start/stop~ and ~step~ combination is invalid (see\nbsp[[valid-input.scm]]) the ~range~ function returns
the empty list.

#+CAPTION: Test suite calling ~range~ with invalid inputs.
#+NAME: test:invalid.scm
#+begin_src scheme
  (test-begin "invalid")

  (define (test-util:invalid start stop step)
    "Utility function to check range resturns empty list when given invalid inputs."
    (and (not (valid-input? start stop step)) ; Test fails if input is *not* invalid.
         (null? (range start stop step))))

  (test-assert "0 1 -" (test-util:invalid 0 1 -1))
  (test-assert "0 -1 +" (test-util:invalid 0 -1 1))
  (test-assert "0 1 0" (test-util:invalid 0 1 0))
  (test-assert "0 -1 0" (test-util:invalid 0 -1 0))

  (test-assert "1 0 +" (test-util:invalid 1 0 1))
  (test-assert "1 -1 +" (test-util:invalid 1 -1 1))
  (test-assert "1 2 -" (test-util:invalid 1 2 -1))
  (test-assert "1 0 0" (test-util:invalid 1 0 0))
  (test-assert "1 -1 0" (test-util:invalid 1 -1 0))
  (test-assert "1 2 0" (test-util:invalid 1 2 -0))

  (test-assert "-1 0 -" (test-util:invalid -1 0 -1))
  (test-assert "-1 1 -" (test-util:invalid -1 1 -1))
  (test-assert "-1 -2 +" (test-util:invalid -1 -2 1))
  (test-assert "-1 0 0" (test-util:invalid -1 0 0))
  (test-assert "-1 1 0" (test-util:invalid -1 1 0))
  (test-assert "-1 -2 0" (test-util:invalid -1 -2 0))

  (test-end "invalid")
#+end_src

** Start

For a valid input the returned list should start at the given ~start~ value.

** Stop

For a valid input the returned list should stop at the entry satisfying $x_{i}+\Delta{}\ge{}X$ where
$x_i$ is the final element, $\Delta$ is the ~step~ and $X$ is the ~stop~ value.

** Step

In the returned list from ~range~ each element should differ from the previous by ~step~, /i.e./
\begin{equation}
  x_{i+1}=x_{i}+\Delta\forall{}i>1
\end{equation}

** Test utilities

This section collects utility functions that are non-specific to a given test.

The ~step~ must allow ~range~ to get from ~start~ to ~stop~.
Therefore a zero ~step~ is invalid, as is a ~step~ with a different sign than the difference ~(- stop
start)~, a valid ~start/stop/step~ combination satisfies the condition tested by ~valid-input?~
in\nbsp[[valid-input.scm]].

#+CAPTION: Function testing validity of input to ~range~.
#+NAME: valid-input.scm
#+begin_src scheme
  (define (valid-input? start stop step)
    "Check that input to range is valid."
    (> (* (- stop start)
          step)
       0))
#+end_src

